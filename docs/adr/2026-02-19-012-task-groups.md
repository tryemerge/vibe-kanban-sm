# ADR 012: Task Groups

**Date:** 2026-02-19
**Status:** Proposed
**Author:** User + Claude
**Supersedes:** ADR-004 swim lane grouping model (labels → task groups)

## Context

InDusk uses worktree-per-task isolation inherited from Vibe Kanban. Each task gets its own git worktree branched from main, works independently, and produces its own PR. Industry research across Codex, Devin, Claude Code teams, Augment Intent, and Factory AI confirms this is the standard model — but it's designed for **parallel independent tasks on large codebases**, not for an individual building something incrementally through a pipeline of sequential, related tasks.

The problem emerges when you queue related tasks. Consider: "add auth model", "add auth API", "add auth UI". Each task branches from main independently. Task B can't see Task A's code because they're in separate worktrees. The existing dependency system (ADR not numbered, `task_dependencies` table) blocks start order — Task B won't start until Task A completes — but doesn't share workspaces. Task B's agent starts fresh from main, unaware of Task A's work until it's merged.

Current swim lanes (ADR-004) are purely cosmetic — UI-level grouping by labels with no database entity and no behavioral implications. Labels remain valuable for tagging and filtering, but swim lanes need a stronger backing concept.

No tool in the industry solves dependent task coordination well. Everyone isolates tasks. The gap is: how do you make sequential, related tasks build on each other's work?

## Decision

### 1. `task_groups` table

A new project-scoped entity representing a group of related tasks that execute sequentially.

```sql
CREATE TABLE task_groups (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    color TEXT,
    position INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(project_id, name)
);
```

### 2. `task_group_id` on tasks

A task belongs to zero or one group. Nullable FK with `ON DELETE SET NULL` — deleting a group ungroups its tasks rather than deleting them.

```sql
ALTER TABLE tasks ADD COLUMN task_group_id UUID REFERENCES task_groups(id) ON DELETE SET NULL;
CREATE INDEX idx_tasks_task_group ON tasks(task_group_id);
```

### 3. Swim lanes use task groups

Replace `groupBy: 'label'` with `groupBy: 'task_group'` as the primary swim lane grouping. The `SwimLaneGroupBy` type gets a new `{ type: 'task_group' }` variant, which becomes the default. Tasks without a group appear in an "Ungrouped" lane. Groups are ordered by `position`.

Labels remain available for tagging and filtering but no longer drive swim lane grouping.

### 4. Auto-dependencies within groups

When a task is added to a group, the system auto-creates a `TaskDependency` from the new task to the previous task in the group (by position). This enforces sequential execution: tasks within a group run one after another, each picking up where the last left off.

To distinguish auto-created dependencies from manual ones, add an `is_auto_group` boolean to `task_dependencies`:

```sql
ALTER TABLE task_dependencies ADD COLUMN is_auto_group BOOLEAN NOT NULL DEFAULT FALSE;
```

When a task is removed from a group, its `is_auto_group` dependencies are cleaned up. Manual dependencies are preserved.

### 5. Group immutability once started

A task group becomes **immutable** once its first task begins execution. No tasks can be added, removed, or reordered within a started group. This prevents a class of race conditions where modifying a running group invalidates an agent's context or breaks the dependency chain mid-execution.

The group tracks its lifecycle via a `started_at` timestamp:

```sql
ALTER TABLE task_groups ADD COLUMN started_at TIMESTAMPTZ;
```

- `started_at IS NULL` → group is mutable (draft/planning phase)
- `started_at IS NOT NULL` → group is frozen (execution phase)

The API enforces this: `add_task_to_group`, `remove_task_from_group`, and `reorder` operations reject with a 409 Conflict if `started_at` is set. The `started_at` timestamp is set automatically when the first task in the group transitions out of `todo` status.

If changes are needed after a group starts, the user creates a **new task group** and adds it to the inter-group dependency graph (see decision 6). This is append-only at the orchestration level — running groups are never mutated, new work extends the plan.

### 6. Inter-group dependency DAG

Task groups relate to each other via a dependency graph (DAG). A `task_group_dependencies` table defines which groups must complete before others can start:

```sql
CREATE TABLE task_group_dependencies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_group_id UUID NOT NULL REFERENCES task_groups(id) ON DELETE CASCADE,
    depends_on_group_id UUID NOT NULL REFERENCES task_groups(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    satisfied_at TIMESTAMPTZ,
    UNIQUE(task_group_id, depends_on_group_id)
);
```

This enables three execution patterns:
- **Sequential**: Group B depends on Group A → B starts after A completes
- **Concurrent**: Group A and Group B have no dependency → execute in parallel
- **Fan-in**: Group C depends on both Group A and Group B → C starts after both complete

The system evaluates the DAG to determine execution order. Groups with no unsatisfied dependencies and a `started_at IS NULL` are eligible to start. When all tasks in a group reach a terminal column, the group's outgoing dependencies are satisfied (`satisfied_at` is set), potentially unblocking downstream groups.

### 7. Future: shared workspace

Task groups will eventually share a single worktree and branch. Each task's agent picks up the worktree where the previous task's agent left off. One PR for the entire group at the end.

This is not in scope for this ADR but the schema supports it — a `workspace_id` column can be added to `task_groups` later without migration complexity.

## Consequences

### Positive
- Tasks within a group are visually grouped in swim lanes on the kanban board
- Tasks within a group execute sequentially via auto-created dependencies
- Groups are immutable once started — no race conditions from mid-execution modifications
- Changes are append-only: new work creates new groups that extend the DAG
- Inter-group DAG enables both sequential pipelines and concurrent execution across domains
- Foundation for shared worktree — the hardest unsolved problem in agent-based coding tools
- Swim lanes become meaningful (backed by a database entity) rather than cosmetic
- Labels remain for flexible tagging and filtering, unburdened from structural responsibility

### Negative
- Adding `task_group_id` to the `tasks` table touches many existing queries
- Auto-dependency management adds complexity to add/remove-from-group operations
- `is_auto_group` flag on dependencies introduces a maintenance concern (must be kept in sync)
- Immutability requires clear UX to communicate why a group can't be edited and how to create a continuation group
- Inter-group DAG adds a second layer of dependency management alongside task-level dependencies

### Future Work
- **Shared workspace per group**: Single worktree/branch shared across all tasks in a group
- **Group-level PR**: One PR for the entire group rather than per-task
- **Group templates**: Predefined sequences of tasks (e.g., "Backend Feature" = model → API → tests)
- **DAG visualization**: Visual graph editor showing group relationships and execution flow
- **Automatic concurrency detection**: Heuristic analysis of task descriptions/file paths to suggest which groups can run in parallel

## Related
- ADR-004: Swim Lanes and Task Labels (swim lane grouping model superseded)
- `crates/db/src/models/task_dependency.rs` — existing dependency system
- `frontend/src/hooks/useSwimLaneConfig.ts` — current swim lane configuration
